"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.scrutinizableResourceTypes = exports.scrutinizablePropertyNames = exports.filteredSpecification = exports.namespaces = exports.resourceTypes = exports.propertySpecification = exports.cfnLintAnnotations = exports.resourceAugmentation = exports.typeDocs = exports.resourceSpecification = exports.docs = exports.specification = exports.schema = void 0;
const crypto = require("crypto");
const schema = require("./schema");
exports.schema = schema;
const schema_1 = require("./schema");
__exportStar(require("./canned-metrics"), exports);
/**
 * The complete AWS CloudFormation Resource specification, having any CDK patches and enhancements included in it.
 */
function specification() {
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const spec = require('../spec/specification.json');
    // Modify spec in place, remove complex attributes
    for (const resource of Object.values(spec.ResourceTypes)) {
        resource.Attributes = Object.fromEntries(Object.entries(resource.Attributes ?? [])
            .filter(([_, attr]) => (0, schema_1.isPrimitiveAttribute)(attr) || (0, schema_1.isListAttribute)(attr) || (0, schema_1.isMapAttribute)(attr)));
    }
    return spec;
}
exports.specification = specification;
/**
 * The complete AWS CloudFormation Resource specification, having any CDK patches and enhancements included in it.
 */
function docs() {
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    return require('../spec/cfn-docs.json');
}
exports.docs = docs;
/**
 * Return the resource specification for the given typename
 *
 * Validates that the resource exists. If you don't want this validating behavior, read from
 * specification() directly.
 */
function resourceSpecification(typeName) {
    const ret = specification().ResourceTypes[typeName];
    if (!ret) {
        throw new Error(`No such resource type: ${typeName}`);
    }
    return ret;
}
exports.resourceSpecification = resourceSpecification;
/**
 * Return documentation for the given type
 */
function typeDocs(resourceName, propertyTypeName) {
    const key = propertyTypeName ? `${resourceName}.${propertyTypeName}` : resourceName;
    const ret = docs().Types[key];
    if (!ret) {
        return {
            description: '',
            properties: {},
        };
    }
    return ret;
}
exports.typeDocs = typeDocs;
/**
 * Get the resource augmentations for a given type
 */
function resourceAugmentation(typeName) {
    const fileName = typeName.replace(/::/g, '_');
    try {
        // eslint-disable-next-line @typescript-eslint/no-require-imports
        return require(`./augmentations/${fileName}.json`);
    }
    catch {
        return {};
    }
}
exports.resourceAugmentation = resourceAugmentation;
/**
 * Get the resource augmentations for a given type
 */
function cfnLintAnnotations(typeName) {
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const allAnnotations = require('../spec/cfn-lint.json');
    return {
        stateful: !!allAnnotations.StatefulResources.ResourceTypes[typeName],
        mustBeEmptyToDelete: allAnnotations.StatefulResources.ResourceTypes[typeName]?.DeleteRequiresEmptyResource ?? false,
    };
}
exports.cfnLintAnnotations = cfnLintAnnotations;
/**
 * Return the property specification for the given resource's property
 */
function propertySpecification(typeName, propertyName) {
    const ret = resourceSpecification(typeName).Properties[propertyName];
    if (!ret) {
        throw new Error(`Resource ${typeName} has no property: ${propertyName}`);
    }
    return ret;
}
exports.propertySpecification = propertySpecification;
/**
 * The list of resource type names defined in the ``specification``.
 */
function resourceTypes() {
    return Object.keys(specification().ResourceTypes);
}
exports.resourceTypes = resourceTypes;
/**
 * The list of namespaces defined in the ``specification``, that is resource name prefixes down to the second ``::``.
 */
function namespaces() {
    return Array.from(new Set(resourceTypes().map(n => n.split('::', 2).join('::'))));
}
exports.namespaces = namespaces;
/**
 * Obtain a filtered version of the AWS CloudFormation specification.
 *
 * @param filter the predicate to be used in order to filter which resource types from the ``Specification`` to extract.
 *         When passed as a ``string``, only the specified resource type will be extracted. When passed as a
 *         ``RegExp``, all matching resource types will be extracted. When passed as a ``function``, all resource
 *         types for which the function returned ``true`` will be extracted.
 *
 * @return a coherent sub-set of the AWS CloudFormation Resource specification, including all property types related
 *     to the selected resource types.
 */
function filteredSpecification(filter) {
    const spec = specification();
    const result = { ResourceTypes: {}, PropertyTypes: {}, Fingerprint: spec.Fingerprint };
    const predicate = makePredicate(filter);
    for (const type of resourceTypes()) {
        if (!predicate(type)) {
            continue;
        }
        result.ResourceTypes[type] = spec.ResourceTypes[type];
        const prefix = `${type}.`;
        for (const propType of Object.keys(spec.PropertyTypes).filter(n => n.startsWith(prefix))) {
            result.PropertyTypes[propType] = spec.PropertyTypes[propType];
        }
    }
    result.Fingerprint = crypto.createHash('sha256').update(JSON.stringify(result)).digest('base64');
    return result;
}
exports.filteredSpecification = filteredSpecification;
/**
 * Creates a predicate function from a given filter.
 *
 * @param filter when provided as a ``string``, performs an exact match comparison.
 *         when provided as a ``RegExp``, performs uses ``str.match(RegExp)``.
 *         when provided as a ``function``, use the function as-is.
 *
 * @returns a predicate function.
 */
function makePredicate(filter) {
    if (typeof filter === 'string') {
        return s => s === filter;
    }
    else if (typeof filter === 'function') {
        return filter;
    }
    else {
        return s => s.match(filter) != null;
    }
}
/**
 * Return the properties of the given type that require the given scrutiny type
 */
function scrutinizablePropertyNames(resourceType, scrutinyTypes) {
    const impl = specification().ResourceTypes[resourceType];
    if (!impl) {
        return [];
    }
    const ret = new Array();
    for (const [propertyName, propertySpec] of Object.entries(impl.Properties || {})) {
        if (scrutinyTypes.includes(propertySpec.ScrutinyType || schema.PropertyScrutinyType.None)) {
            ret.push(propertyName);
        }
    }
    return ret;
}
exports.scrutinizablePropertyNames = scrutinizablePropertyNames;
/**
 * Return the names of the resource types that need to be subjected to additional scrutiny
 */
function scrutinizableResourceTypes(scrutinyTypes) {
    const ret = new Array();
    for (const [resourceType, resourceSpec] of Object.entries(specification().ResourceTypes)) {
        if (scrutinyTypes.includes(resourceSpec.ScrutinyType || schema.ResourceScrutinyType.None)) {
            ret.push(resourceType);
        }
    }
    return ret;
}
exports.scrutinizableResourceTypes = scrutinizableResourceTypes;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGlDQUFpQztBQUVqQyxtQ0FBbUM7QUFFMUIsd0JBQU07QUFEZixxQ0FBaUY7QUFFakYsbURBQWlDO0FBRWpDOztHQUVHO0FBQ0gsU0FBZ0IsYUFBYTtJQUMzQixpRUFBaUU7SUFDakUsTUFBTSxJQUFJLEdBQXlCLE9BQU8sQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO0lBRXpFLGtEQUFrRDtJQUNsRCxLQUFLLE1BQU0sUUFBUSxJQUFJLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxFQUFFO1FBQ3hELFFBQVEsQ0FBQyxVQUFVLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxVQUFVLElBQUksRUFBRSxDQUFDO2FBQy9FLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFBLDZCQUFvQixFQUFDLElBQUksQ0FBQyxJQUFJLElBQUEsd0JBQWUsRUFBQyxJQUFJLENBQUMsSUFBSSxJQUFBLHVCQUFjLEVBQUMsSUFBSSxDQUFDLENBQUUsQ0FBQyxDQUFDO0tBQ3pHO0lBRUQsT0FBTyxJQUFJLENBQUM7QUFDZCxDQUFDO0FBWEQsc0NBV0M7QUFFRDs7R0FFRztBQUNILFNBQWdCLElBQUk7SUFDbEIsaUVBQWlFO0lBQ2pFLE9BQU8sT0FBTyxDQUFDLHVCQUF1QixDQUFDLENBQUM7QUFDMUMsQ0FBQztBQUhELG9CQUdDO0FBR0Q7Ozs7O0dBS0c7QUFDSCxTQUFnQixxQkFBcUIsQ0FBQyxRQUFnQjtJQUNwRCxNQUFNLEdBQUcsR0FBRyxhQUFhLEVBQUUsQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDcEQsSUFBSSxDQUFDLEdBQUcsRUFBRTtRQUNSLE1BQU0sSUFBSSxL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IHsgQ2ZuTGludEZpbGVTY2hlbWEgfSBmcm9tICcuL19wcml2YXRlX3NjaGVtYS9jZm4tbGludCc7XG5pbXBvcnQgKiBhcyBzY2hlbWEgZnJvbSAnLi9zY2hlbWEnO1xuaW1wb3J0IHsgaXNQcmltaXRpdmVBdHRyaWJ1dGUsIGlzTGlzdEF0dHJpYnV0ZSwgaXNNYXBBdHRyaWJ1dGUgfSBmcm9tICcuL3NjaGVtYSc7XG5leHBvcnQgeyBzY2hlbWEgfTtcbmV4cG9ydCAqIGZyb20gJy4vY2FubmVkLW1ldHJpY3MnO1xuXG4vKipcbiAqIFRoZSBjb21wbGV0ZSBBV1MgQ2xvdWRGb3JtYXRpb24gUmVzb3VyY2Ugc3BlY2lmaWNhdGlvbiwgaGF2aW5nIGFueSBDREsgcGF0Y2hlcyBhbmQgZW5oYW5jZW1lbnRzIGluY2x1ZGVkIGluIGl0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3BlY2lmaWNhdGlvbigpOiBzY2hlbWEuU3BlY2lmaWNhdGlvbiB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzXG4gIGNvbnN0IHNwZWM6IHNjaGVtYS5TcGVjaWZpY2F0aW9uID0gcmVxdWlyZSgnLi4vc3BlYy9zcGVjaWZpY2F0aW9uLmpzb24nKTtcblxuICAvLyBNb2RpZnkgc3BlYyBpbiBwbGFjZSwgcmVtb3ZlIGNvbXBsZXggYXR0cmlidXRlc1xuICBmb3IgKGNvbnN0IHJlc291cmNlIG9mIE9iamVjdC52YWx1ZXMoc3BlYy5SZXNvdXJjZVR5cGVzKSkge1xuICAgIHJlc291cmNlLkF0dHJpYnV0ZXMgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMocmVzb3VyY2UuQXR0cmlidXRlcyA/PyBbXSlcbiAgICAgIC5maWx0ZXIoKFtfLCBhdHRyXSkgPT4gaXNQcmltaXRpdmVBdHRyaWJ1dGUoYXR0cikgfHwgaXNMaXN0QXR0cmlidXRlKGF0dHIpIHx8IGlzTWFwQXR0cmlidXRlKGF0dHIpICkpO1xuICB9XG5cbiAgcmV0dXJuIHNwZWM7XG59XG5cbi8qKlxuICogVGhlIGNvbXBsZXRlIEFXUyBDbG91ZEZvcm1hdGlvbiBSZXNvdXJjZSBzcGVjaWZpY2F0aW9uLCBoYXZpbmcgYW55IENESyBwYXRjaGVzIGFuZCBlbmhhbmNlbWVudHMgaW5jbHVkZWQgaW4gaXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkb2NzKCk6IHNjaGVtYS5DbG91ZEZvcm1hdGlvbkRvY3NGaWxlIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgcmV0dXJuIHJlcXVpcmUoJy4uL3NwZWMvY2ZuLWRvY3MuanNvbicpO1xufVxuXG5cbi8qKlxuICogUmV0dXJuIHRoZSByZXNvdXJjZSBzcGVjaWZpY2F0aW9uIGZvciB0aGUgZ2l2ZW4gdHlwZW5hbWVcbiAqXG4gKiBWYWxpZGF0ZXMgdGhhdCB0aGUgcmVzb3VyY2UgZXhpc3RzLiBJZiB5b3UgZG9uJ3Qgd2FudCB0aGlzIHZhbGlkYXRpbmcgYmVoYXZpb3IsIHJlYWQgZnJvbVxuICogc3BlY2lmaWNhdGlvbigpIGRpcmVjdGx5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb3VyY2VTcGVjaWZpY2F0aW9uKHR5cGVOYW1lOiBzdHJpbmcpOiBzY2hlbWEuUmVzb3VyY2VUeXBlIHtcbiAgY29uc3QgcmV0ID0gc3BlY2lmaWNhdGlvbigpLlJlc291cmNlVHlwZXNbdHlwZU5hbWVdO1xuICBpZiAoIXJldCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm8gc3VjaCByZXNvdXJjZSB0eXBlOiAke3R5cGVOYW1lfWApO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogUmV0dXJuIGRvY3VtZW50YXRpb24gZm9yIHRoZSBnaXZlbiB0eXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0eXBlRG9jcyhyZXNvdXJjZU5hbWU6IHN0cmluZywgcHJvcGVydHlUeXBlTmFtZT86IHN0cmluZyk6IHNjaGVtYS5DbG91ZEZvcm1hdGlvblR5cGVEb2NzIHtcbiAgY29uc3Qga2V5ID0gcHJvcGVydHlUeXBlTmFtZSA/IGAke3Jlc291cmNlTmFtZX0uJHtwcm9wZXJ0eVR5cGVOYW1lfWAgOiByZXNvdXJjZU5hbWU7XG4gIGNvbnN0IHJldCA9IGRvY3MoKS5UeXBlc1trZXldO1xuICBpZiAoIXJldCkge1xuICAgIHJldHVybiB7XG4gICAgICBkZXNjcmlwdGlvbjogJycsXG4gICAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICB9O1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogR2V0IHRoZSByZXNvdXJjZSBhdWdtZW50YXRpb25zIGZvciBhIGdpdmVuIHR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc291cmNlQXVnbWVudGF0aW9uKHR5cGVOYW1lOiBzdHJpbmcpOiBzY2hlbWEuUmVzb3VyY2VBdWdtZW50YXRpb24ge1xuICBjb25zdCBmaWxlTmFtZSA9IHR5cGVOYW1lLnJlcGxhY2UoLzo6L2csICdfJyk7XG4gIHRyeSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgICByZXR1cm4gcmVxdWlyZShgLi9hdWdtZW50YXRpb25zLyR7ZmlsZU5hbWV9Lmpzb25gKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSByZXNvdXJjZSBhdWdtZW50YXRpb25zIGZvciBhIGdpdmVuIHR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNmbkxpbnRBbm5vdGF0aW9ucyh0eXBlTmFtZTogc3RyaW5nKTogc2NoZW1hLkNmbkxpbnRSZXNvdXJjZUFubm90YXRpb25zIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgY29uc3QgYWxsQW5ub3RhdGlvbnM6IENmbkxpbnRGaWxlU2NoZW1hID0gcmVxdWlyZSgnLi4vc3BlYy9jZm4tbGludC5qc29uJyk7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGF0ZWZ1bDogISFhbGxBbm5vdGF0aW9ucy5TdGF0ZWZ1bFJlc291cmNlcy5SZXNvdXJjZVR5cGVzW3R5cGVOYW1lXSxcbiAgICBtdXN0QmVFbXB0eVRvRGVsZXRlOiBhbGxBbm5vdGF0aW9ucy5TdGF0ZWZ1bFJlc291cmNlcy5SZXNvdXJjZVR5cGVzW3R5cGVOYW1lXT8uRGVsZXRlUmVxdWlyZXNFbXB0eVJlc291cmNlID8/IGZhbHNlLFxuICB9O1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgcHJvcGVydHkgc3BlY2lmaWNhdGlvbiBmb3IgdGhlIGdpdmVuIHJlc291cmNlJ3MgcHJvcGVydHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb3BlcnR5U3BlY2lmaWNhdGlvbih0eXBlTmFtZTogc3RyaW5nLCBwcm9wZXJ0eU5hbWU6IHN0cmluZyk6IHNjaGVtYS5Qcm9wZXJ0eSB7XG4gIGNvbnN0IHJldCA9IHJlc291cmNlU3BlY2lmaWNhdGlvbih0eXBlTmFtZSkuUHJvcGVydGllcyFbcHJvcGVydHlOYW1lXTtcbiAgaWYgKCFyZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFJlc291cmNlICR7dHlwZU5hbWV9IGhhcyBubyBwcm9wZXJ0eTogJHtwcm9wZXJ0eU5hbWV9YCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdCBvZiByZXNvdXJjZSB0eXBlIG5hbWVzIGRlZmluZWQgaW4gdGhlIGBgc3BlY2lmaWNhdGlvbmBgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb3VyY2VUeXBlcygpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHNwZWNpZmljYXRpb24oKS5SZXNvdXJjZVR5cGVzKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdCBvZiBuYW1lc3BhY2VzIGRlZmluZWQgaW4gdGhlIGBgc3BlY2lmaWNhdGlvbmBgLCB0aGF0IGlzIHJlc291cmNlIG5hbWUgcHJlZml4ZXMgZG93biB0byB0aGUgc2Vjb25kIGBgOjpgYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5hbWVzcGFjZXMoKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQocmVzb3VyY2VUeXBlcygpLm1hcChuID0+IG4uc3BsaXQoJzo6JywgMikuam9pbignOjonKSkpKTtcbn1cblxuLyoqXG4gKiBPYnRhaW4gYSBmaWx0ZXJlZCB2ZXJzaW9uIG9mIHRoZSBBV1MgQ2xvdWRGb3JtYXRpb24gc3BlY2lmaWNhdGlvbi5cbiAqXG4gKiBAcGFyYW0gZmlsdGVyIHRoZSBwcmVkaWNhdGUgdG8gYmUgdXNlZCBpbiBvcmRlciB0byBmaWx0ZXIgd2hpY2ggcmVzb3VyY2UgdHlwZXMgZnJvbSB0aGUgYGBTcGVjaWZpY2F0aW9uYGAgdG8gZXh0cmFjdC5cbiAqICAgICAgICAgV2hlbiBwYXNzZWQgYXMgYSBgYHN0cmluZ2BgLCBvbmx5IHRoZSBzcGVjaWZpZWQgcmVzb3VyY2UgdHlwZSB3aWxsIGJlIGV4dHJhY3RlZC4gV2hlbiBwYXNzZWQgYXMgYVxuICogICAgICAgICBgYFJlZ0V4cGBgLCBhbGwgbWF0Y2hpbmcgcmVzb3VyY2UgdHlwZXMgd2lsbCBiZSBleHRyYWN0ZWQuIFdoZW4gcGFzc2VkIGFzIGEgYGBmdW5jdGlvbmBgLCBhbGwgcmVzb3VyY2VcbiAqICAgICAgICAgdHlwZXMgZm9yIHdoaWNoIHRoZSBmdW5jdGlvbiByZXR1cm5lZCBgYHRydWVgYCB3aWxsIGJlIGV4dHJhY3RlZC5cbiAqXG4gKiBAcmV0dXJuIGEgY29oZXJlbnQgc3ViLXNldCBvZiB0aGUgQVdTIENsb3VkRm9ybWF0aW9uIFJlc291cmNlIHNwZWNpZmljYXRpb24sIGluY2x1ZGluZyBhbGwgcHJvcGVydHkgdHlwZXMgcmVsYXRlZFxuICogICAgIHRvIHRoZSBzZWxlY3RlZCByZXNvdXJjZSB0eXBlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlcmVkU3BlY2lmaWNhdGlvbihmaWx0ZXI6IHN0cmluZyB8IFJlZ0V4cCB8IEZpbHRlcik6IHNjaGVtYS5TcGVjaWZpY2F0aW9uIHtcbiAgY29uc3Qgc3BlYyA9IHNwZWNpZmljYXRpb24oKTtcblxuICBjb25zdCByZXN1bHQ6IHNjaGVtYS5TcGVjaWZpY2F0aW9uID0geyBSZXNvdXJjZVR5cGVzOiB7fSwgUHJvcGVydHlUeXBlczoge30sIEZpbmdlcnByaW50OiBzcGVjLkZpbmdlcnByaW50IH07XG4gIGNvbnN0IHByZWRpY2F0ZTogRmlsdGVyID0gbWFrZVByZWRpY2F0ZShmaWx0ZXIpO1xuICBmb3IgKGNvbnN0IHR5cGUgb2YgcmVzb3VyY2VUeXBlcygpKSB7XG4gICAgaWYgKCFwcmVkaWNhdGUodHlwZSkpIHsgY29udGludWU7IH1cbiAgICByZXN1bHQuUmVzb3VyY2VUeXBlc1t0eXBlXSA9IHNwZWMuUmVzb3VyY2VUeXBlc1t0eXBlXTtcbiAgICBjb25zdCBwcmVmaXggPSBgJHt0eXBlfS5gO1xuICAgIGZvciAoY29uc3QgcHJvcFR5cGUgb2YgT2JqZWN0LmtleXMoc3BlYy5Qcm9wZXJ0eVR5cGVzISkuZmlsdGVyKG4gPT4gbi5zdGFydHNXaXRoKHByZWZpeCkpKSB7XG4gICAgICByZXN1bHQuUHJvcGVydHlUeXBlc1twcm9wVHlwZV0gPSBzcGVjLlByb3BlcnR5VHlwZXMhW3Byb3BUeXBlXTtcbiAgICB9XG4gIH1cbiAgcmVzdWx0LkZpbmdlcnByaW50ID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShKU09OLnN0cmluZ2lmeShyZXN1bHQpKS5kaWdlc3QoJ2Jhc2U2NCcpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgdHlwZSBGaWx0ZXIgPSAobmFtZTogc3RyaW5nKSA9PiBib29sZWFuO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBwcmVkaWNhdGUgZnVuY3Rpb24gZnJvbSBhIGdpdmVuIGZpbHRlci5cbiAqXG4gKiBAcGFyYW0gZmlsdGVyIHdoZW4gcHJvdmlkZWQgYXMgYSBgYHN0cmluZ2BgLCBwZXJmb3JtcyBhbiBleGFjdCBtYXRjaCBjb21wYXJpc29uLlxuICogICAgICAgICB3aGVuIHByb3ZpZGVkIGFzIGEgYGBSZWdFeHBgYCwgcGVyZm9ybXMgdXNlcyBgYHN0ci5tYXRjaChSZWdFeHApYGAuXG4gKiAgICAgICAgIHdoZW4gcHJvdmlkZWQgYXMgYSBgYGZ1bmN0aW9uYGAsIHVzZSB0aGUgZnVuY3Rpb24gYXMtaXMuXG4gKlxuICogQHJldHVybnMgYSBwcmVkaWNhdGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1ha2VQcmVkaWNhdGUoZmlsdGVyOiBzdHJpbmcgfCBSZWdFeHAgfCBGaWx0ZXIpOiBGaWx0ZXIge1xuICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcyA9PiBzID09PSBmaWx0ZXI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmaWx0ZXIgYXMgRmlsdGVyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzID0+IHMubWF0Y2goZmlsdGVyKSAhPSBudWxsO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBnaXZlbiB0eXBlIHRoYXQgcmVxdWlyZSB0aGUgZ2l2ZW4gc2NydXRpbnkgdHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NydXRpbml6YWJsZVByb3BlcnR5TmFtZXMocmVzb3VyY2VUeXBlOiBzdHJpbmcsIHNjcnV0aW55VHlwZXM6IHNjaGVtYS5Qcm9wZXJ0eVNjcnV0aW55VHlwZVtdKTogc3RyaW5nW10ge1xuICBjb25zdCBpbXBsID0gc3BlY2lmaWNhdGlvbigpLlJlc291cmNlVHlwZXNbcmVzb3VyY2VUeXBlXTtcbiAgaWYgKCFpbXBsKSB7IHJldHVybiBbXTsgfVxuXG4gIGNvbnN0IHJldCA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG5cbiAgZm9yIChjb25zdCBbcHJvcGVydHlOYW1lLCBwcm9wZXJ0eVNwZWNdIG9mIE9iamVjdC5lbnRyaWVzKGltcGwuUHJvcGVydGllcyB8fCB7fSkpIHtcbiAgICBpZiAoc2NydXRpbnlUeXBlcy5pbmNsdWRlcyhwcm9wZXJ0eVNwZWMuU2NydXRpbnlUeXBlIHx8IHNjaGVtYS5Qcm9wZXJ0eVNjcnV0aW55VHlwZS5Ob25lKSkge1xuICAgICAgcmV0LnB1c2gocHJvcGVydHlOYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgbmFtZXMgb2YgdGhlIHJlc291cmNlIHR5cGVzIHRoYXQgbmVlZCB0byBiZSBzdWJqZWN0ZWQgdG8gYWRkaXRpb25hbCBzY3J1dGlueVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NydXRpbml6YWJsZVJlc291cmNlVHlwZXMoc2NydXRpbnlUeXBlczogc2NoZW1hLlJlc291cmNlU2NydXRpbnlUeXBlW10pOiBzdHJpbmdbXSB7XG4gIGNvbnN0IHJldCA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG4gIGZvciAoY29uc3QgW3Jlc291cmNlVHlwZSwgcmVzb3VyY2VTcGVjXSBvZiBPYmplY3QuZW50cmllcyhzcGVjaWZpY2F0aW9uKCkuUmVzb3VyY2VUeXBlcykpIHtcbiAgICBpZiAoc2NydXRpbnlUeXBlcy5pbmNsdWRlcyhyZXNvdXJjZVNwZWMuU2NydXRpbnlUeXBlIHx8IHNjaGVtYS5SZXNvdXJjZVNjcnV0aW55VHlwZS5Ob25lKSkge1xuICAgICAgcmV0LnB1c2gocmVzb3VyY2VUeXBlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuIl19