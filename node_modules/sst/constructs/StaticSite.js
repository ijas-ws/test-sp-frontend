import path from "path";
import url from "url";
import fs from "fs";
import crypto from "crypto";
import { execSync } from "child_process";
import { Construct } from "constructs";
import { Token, Duration, RemovalPolicy, CustomResource, } from "aws-cdk-lib";
import { BlockPublicAccess, Bucket, } from "aws-cdk-lib/aws-s3";
import { Asset } from "aws-cdk-lib/aws-s3-assets";
import { Effect, Policy, PolicyStatement } from "aws-cdk-lib/aws-iam";
import { Code, Function, Runtime } from "aws-cdk-lib/aws-lambda";
import { HostedZone, ARecord, AaaaRecord, RecordTarget, } from "aws-cdk-lib/aws-route53";
import { CloudFrontTarget } from "aws-cdk-lib/aws-route53-targets";
import { Distribution, Function as CfFunction, FunctionCode as CfFunctionCode, FunctionEventType as CfFunctionEventType, ViewerProtocolPolicy, } from "aws-cdk-lib/aws-cloudfront";
import { S3Origin } from "aws-cdk-lib/aws-cloudfront-origins";
import { AwsCliLayer } from "aws-cdk-lib/lambda-layer-awscli";
import { Stack } from "./Stack.js";
import { getBuildCmdEnvironment, buildErrorResponsesFor404ErrorPage, buildErrorResponsesForRedirectToIndex, } from "./BaseSite.js";
import { HttpsRedirect } from "./cdk/website-redirect.js";
import { DnsValidatedCertificate } from "./cdk/dns-validated-certificate.js";
import { isCDKConstruct } from "./Construct.js";
import { getParameterPath, } from "./util/functionBinding.js";
import { gray } from "colorette";
import { useProject } from "../project.js";
const __dirname = path.dirname(url.fileURLToPath(import.meta.url));
/////////////////////
// Construct
/////////////////////
/**
 * The `StaticSite` construct is a higher level CDK construct that makes it easy to create a static website.
 *
 * @example
 *
 * Deploys a plain HTML website in the `path/to/src` directory.
 *
 * ```js
 * import { StaticSite } from "sst/constructs";
 *
 * new StaticSite(stack, "Site", {
 *   path: "path/to/src",
 * });
 * ```
 */
export class StaticSite extends Construct {
    id;
    props;
    doNotDeploy;
    bucket;
    distribution;
    hostedZone;
    certificate;
    constructor(scope, id, props) {
        super(scope, props?.cdk?.id || id);
        const app = scope.node.root;
        const stack = Stack.of(this);
        this.id = id;
        this.props = {
            path: ".",
            waitForInvalidation: false,
            ...props,
        };
        this.doNotDeploy =
            !stack.isActive || (app.mode === "dev" && !this.props.dev?.deploy);
        this.validateCustomDomainSettings();
        this.generateViteTypes();
        if (this.doNotDeploy) {
            // @ts-ignore
            this.bucket = this.distribution = null;
            return;
        }
        const cliLayer = new AwsCliLayer(this, "AwsCliLayer");
        // Build app
        const fileSizeLimit = app.isRunningSSTTest()
            ? // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore: "sstTestFileSizeLimitOverride" not exposed in props
                this.props.sstTestFileSizeLimitOverride || 200
            : 200;
        this.buildApp();
        const assets = this.bundleAssets(fileSizeLimit);
        const filenamesAsset = this.bundleFilenamesAsset();
        // Create Bucket
        this.bucket = this.createS3Bucket();
        // Create Custom Domain
        this.hostedZone = this.lookupHostedZone();
        this.certificate = this.createCertificate();
        // Create S3 Deployment
        const s3deployCR = this.createS3Deployment(cliLayer, assets, filenamesAsset);
        // Create CloudFront
        this.validateCloudFrontDistributionSettings();
        this.distribution = this.createCfDistribution();
        this.distribution.node.addDependency(s3deployCR);
        // Invalidate CloudFront
        const invalidationCR = this.createCloudFrontInvalidation(assets);
        invalidationCR.node.addDependency(this.distribution);
        // Connect Custom Domain to CloudFront Distribution
        this.createRoute53Records();
    }
    /**
     * The CloudFront URL of the website.
     */
    get url() {
        if (this.doNotDeploy)
            return;
        return `https://${this.distribution.distributionDomainName}`;
    }
    /**
     * If the custom domain is enabled, this is the URL of the website with the custom domain.
     */
    get customDomainUrl() {
        if (this.doNotDeploy)
            return;
        const { customDomain } = this.props;
        if (!customDomain)
            return;
        if (typeof customDomain === "string") {
            return `https://${customDomain}`;
        }
        else {
            return `https://${customDomain.domainName}`;
        }
    }
    /**
     * The internally created CDK resources.
     */
    get cdk() {
        if (this.doNotDeploy)
            return;
        return {
            bucket: this.bucket,
            distribution: this.distribution,
            hostedZone: this.hostedZone,
            certificate: this.certificate,
        };
    }
    getConstructMetadata() {
        return {
            type: "StaticSite",
            data: {
                path: this.props.path,
                environment: this.props.environment || {},
                customDomainUrl: this.customDomainUrl,
            },
        };
    }
    /** @internal */
    getFunctionBinding() {
        const app = this.node.root;
        return {
            clientPackage: "site",
            variables: {
                url: this.doNotDeploy
                    ? {
                        type: "plain",
                        value: "localhost",
                    }
                    : {
                        // Do not set real value b/c we don't want to make the Lambda function
                        // depend on the Site. B/c often the site depends on the Api, causing
                        // a CloudFormation circular dependency if the Api and the Site belong
                        // to different stacks.
                        type: "site_url",
                        value: this.customDomainUrl || this.url,
                    },
            },
            permissions: {
                "ssm:GetParameters": [
                    `arn:${Stack.of(this).partition}:ssm:${app.region}:${app.account}:parameter${getParameterPath(this, "url")}`,
                ],
            },
        };
    }
    generateViteTypes() {
        const { path: sitePath, environment } = this.props;
        // Build the path
        let typesPath = this.props.vite?.types;
        if (!typesPath) {
            if (fs.existsSync(path.join(sitePath, "vite.config.js")) ||
                fs.existsSync(path.join(sitePath, "vite.config.ts"))) {
                typesPath = "src/sst-env.d.ts";
            }
        }
        if (!typesPath) {
            return;
        }
        // Create type file
        const filePath = path.resolve(path.join(sitePath, typesPath));
        const content = `/// <reference types="vite/client" />
interface ImportMetaEnv {
${Object.keys(environment || {})
            .map((key) => `  readonly ${key}: string`)
            .join("\n")}
}
interface ImportMeta {
  readonly env: ImportMetaEnv
}`;
        const fileDir = path.dirname(filePath);
        fs.mkdirSync(fileDir, { recursive: true });
        fs.writeFileSync(filePath, content);
    }
    buildApp() {
        const { path: sitePath, buildCommand } = this.props;
        // validate site path exists
        if (!fs.existsSync(sitePath)) {
            throw new Error(`No path found at "${path.resolve(sitePath)}" for the "${this.node.id}" StaticSite.`);
        }
        // build
        if (buildCommand) {
            try {
                console.log(gray(`Building static site ${sitePath}`));
                execSync(buildCommand, {
                    cwd: sitePath,
                    stdio: "inherit",
                    env: {
                        ...process.env,
                        ...getBuildCmdEnvironment(this.props.environment),
                    },
                });
            }
            catch (e) {
                throw new Error(`There was a problem building the "${this.node.id}" StaticSite.`);
            }
        }
    }
    bundleAssets(fileSizeLimit) {
        const { path: sitePath } = this.props;
        const buildOutput = this.props.buildOutput || ".";
        // validate buildOutput exists
        const siteOutputPath = path.resolve(path.join(sitePath, buildOutput));
        if (!fs.existsSync(siteOutputPath)) {
            throw new Error(`No build output found at "${siteOutputPath}" for the "${this.node.id}" StaticSite.`);
        }
        // create zip files
        const script = path.join(__dirname, "../support/base-site-archiver.mjs");
        const zipPath = path.resolve(path.join(useProject().paths.artifacts, `StaticSite-${this.node.id}-${this.node.addr}`));
        // clear zip path to ensure no partX.zip remain from previous build
        fs.rmSync(zipPath, {
            force: true,
            recursive: true,
        });
        const cmd = ["node", script, siteOutputPath, zipPath, fileSizeLimit].join(" ");
        try {
            execSync(cmd, {
                cwd: sitePath,
                stdio: "inherit",
            });
        }
        catch (e) {
            throw new Error(`There was a problem generating the "${this.node.id}" StaticSite package.`);
        }
        // create assets
        const assets = [];
        for (let partId = 0;; partId++) {
            const zipFilePath = path.join(zipPath, `part${partId}.zip`);
            if (!fs.existsSync(zipFilePath)) {
                break;
            }
            assets.push(new Asset(this, `Asset${partId}`, {
                path: zipFilePath,
            }));
        }
        return assets;
    }
    bundleFilenamesAsset() {
        if (this.props.purgeFiles === false) {
            return;
        }
        const zipPath = path.resolve(path.join(useProject().paths.artifacts, `StaticSite-${this.node.id}-${this.node.addr}`));
        // create assets
        const filenamesPath = path.join(zipPath, `filenames`);
        if (!fs.existsSync(filenamesPath)) {
            throw new Error(`There was a problem generating the "${this.node.id}" StaticSite package.`);
        }
        return new Asset(this, `AssetFilenames`, {
            path: filenamesPath,
        });
    }
    createS3Bucket() {
        const { cdk } = this.props;
        // cdk.bucket is an imported construct
        if (cdk?.bucket && isCDKConstruct(cdk?.bucket)) {
            return cdk.bucket;
        }
        // cdk.bucket is a prop
        else {
            const bucketProps = cdk?.bucket;
            // Validate s3Bucket
            if (bucketProps?.websiteIndexDocument) {
                throw new Error(`Do not configure the "s3Bucket.websiteIndexDocument". Use the "indexPage" to configure the StaticSite index page.`);
            }
            if (bucketProps?.websiteErrorDocument) {
                throw new Error(`Do not configure the "s3Bucket.websiteErrorDocument". Use the "errorPage" to configure the StaticSite index page.`);
            }
            return new Bucket(this, "S3Bucket", {
                publicReadAccess: false,
                blockPublicAccess: BlockPublicAccess.BLOCK_ALL,
                autoDeleteObjects: true,
                removalPolicy: RemovalPolicy.DESTROY,
                ...bucketProps,
            });
        }
    }
    createS3Deployment(cliLayer, assets, filenamesAsset) {
        const fileOptions = this.props.fileOptions || [
            {
                exclude: "*",
                include: "*.html",
                cacheControl: "max-age=0,no-cache,no-store,must-revalidate",
            },
            {
                exclude: "*",
                include: ["*.js", "*.css"],
                cacheControl: "max-age=31536000,public,immutable",
            },
        ];
        // Create a Lambda function that will be doing the uploading
        const uploader = new Function(this, "S3Uploader", {
            code: Code.fromAsset(path.join(__dirname, "../support/base-site-custom-resource")),
            layers: [cliLayer],
            runtime: Runtime.PYTHON_3_7,
            handler: "s3-upload.handler",
            timeout: Duration.minutes(15),
            memorySize: 1024,
        });
        this.bucket.grantReadWrite(uploader);
        assets.forEach((asset) => asset.grantRead(uploader));
        // Create the custom resource function
        const handler = new Function(this, "S3Handler", {
            code: Code.fromAsset(path.join(__dirname, "../support/base-site-custom-resource")),
            layers: [cliLayer],
            runtime: Runtime.PYTHON_3_7,
            handler: "s3-handler.handler",
            timeout: Duration.minutes(15),
            memorySize: 1024,
            environment: {
                UPLOADER_FUNCTION_NAME: uploader.functionName,
            },
        });
        this.bucket.grantReadWrite(handler);
        filenamesAsset?.grantRead(handler);
        uploader.grantInvoke(handler);
        // Create custom resource
        return new CustomResource(this, "S3Deployment", {
            serviceToken: handler.functionArn,
            resourceType: "Custom::SSTBucketDeployment",
            properties: {
                Sources: assets.map((asset) => ({
                    BucketName: asset.s3BucketName,
                    ObjectKey: asset.s3ObjectKey,
                })),
                DestinationBucketName: this.bucket.bucketName,
                Filenames: filenamesAsset && {
                    BucketName: filenamesAsset.s3BucketName,
                    ObjectKey: filenamesAsset.s3ObjectKey,
                },
                FileOptions: (fileOptions || []).map(({ exclude, include, cacheControl }) => {
                    if (typeof exclude === "string") {
                        exclude = [exclude];
                    }
                    if (typeof include === "string") {
                        include = [include];
                    }
                    const options = [];
                    exclude.forEach((per) => options.push("--exclude", per));
                    include.forEach((per) => options.push("--include", per));
                    options.push("--cache-control", cacheControl);
                    return options;
                }),
                ReplaceValues: this.getS3ContentReplaceValues(),
            },
        });
    }
    /////////////////////
    // CloudFront Distribution
    /////////////////////
    validateCloudFrontDistributionSettings() {
        const { cdk, errorPage } = this.props;
        if (cdk?.distribution?.certificate) {
            throw new Error(`Do not configure the "cfDistribution.certificate". Use the "customDomain" to configure the domain certificate.`);
        }
        if (cdk?.distribution?.domainNames) {
            throw new Error(`Do not configure the "cfDistribution.domainNames". Use the "customDomain" to configure the domain name.`);
        }
        if (errorPage && cdk?.distribution?.errorResponses) {
            throw new Error(`Cannot configure the "cfDistribution.errorResponses" when "errorPage" is passed in. Use one or the other to configure the behavior for error pages.`);
        }
    }
    createCfDistribution() {
        const { cdk, errorPage } = this.props;
        const indexPage = this.props.indexPage || "index.html";
        // Create CloudFront distribution
        return new Distribution(this, "Distribution", {
            // these values can be overwritten by cfDistributionProps
            defaultRootObject: indexPage,
            errorResponses: !errorPage || errorPage === "redirect_to_index_page"
                ? buildErrorResponsesForRedirectToIndex(indexPage)
                : buildErrorResponsesFor404ErrorPage(errorPage),
            ...cdk?.distribution,
            // these values can NOT be overwritten by cfDistributionProps
            domainNames: this.buildDistributionDomainNames(),
            certificate: this.certificate,
            defaultBehavior: this.buildDistributionBehavior(),
        });
    }
    createCloudFrontInvalidation(assets) {
        const stack = Stack.of(this);
        // Need the AssetHash field so the CR gets updated on each deploy
        const assetsHash = crypto
            .createHash("md5")
            .update(assets.map(({ assetHash }) => assetHash).join(""))
            .digest("hex");
        const policy = new Policy(this, "CloudFrontInvalidatorPolicy", {
            statements: [
                new PolicyStatement({
                    effect: Effect.ALLOW,
                    actions: [
                        "cloudfront:GetInvalidation",
                        "cloudfront:CreateInvalidation",
                    ],
                    resources: [
                        `arn:${stack.partition}:cloudfront::${stack.account}:distribution/${this.distribution.distributionId}`,
                    ],
                }),
            ],
        });
        stack.customResourceHandler.role?.attachInlinePolicy(policy);
        const resource = new CustomResource(this, "CloudFrontInvalidator", {
            serviceToken: stack.customResourceHandler.functionArn,
            resourceType: "Custom::CloudFrontInvalidator",
            properties: {
                assetsHash,
                distributionId: this.distribution.distributionId,
                paths: ["/*"],
                waitForInvalidation: this.props.waitForInvalidation,
            },
        });
        resource.node.addDependency(policy);
        return resource;
    }
    buildDistributionDomainNames() {
        const { customDomain } = this.props;
        const domainNames = [];
        if (!customDomain) {
            // no domain
        }
        else if (typeof customDomain === "string") {
            domainNames.push(customDomain);
        }
        else {
            domainNames.push(customDomain.domainName);
            if (customDomain.alternateNames) {
                if (!customDomain.cdk?.certificate)
                    throw new Error("Certificates for alternate domains cannot be automatically created. Please specify certificate to use");
                domainNames.push(...customDomain.alternateNames);
            }
        }
        return domainNames;
    }
    buildDistributionBehavior() {
        const { cdk } = this.props;
        return {
            origin: new S3Origin(this.bucket),
            viewerProtocolPolicy: ViewerProtocolPolicy.REDIRECT_TO_HTTPS,
            functionAssociations: [
                {
                    function: new CfFunction(this, "CloudFrontFunction", {
                        code: CfFunctionCode.fromInline(`
function handler(event) {
  var request = event.request;
  var uri = request.uri;
  
  if (uri.endsWith("/")) {
    request.uri += "index.html";
  } else if (!uri.split("/").pop().includes(".")) {
    request.uri += ".html";
  }

  return request;
}
          `),
                    }),
                    eventType: CfFunctionEventType.VIEWER_REQUEST,
                },
            ],
            ...cdk?.distribution?.defaultBehavior,
        };
    }
    /////////////////////
    // Custom Domain
    /////////////////////
    validateCustomDomainSettings() {
        const { customDomain } = this.props;
        if (!customDomain) {
            return;
        }
        if (typeof customDomain === "string") {
            return;
        }
        if (customDomain.isExternalDomain === true) {
            if (!customDomain.cdk?.certificate) {
                throw new Error(`A valid certificate is required when "isExternalDomain" is set to "true".`);
            }
            if (customDomain.domainAlias) {
                throw new Error(`Domain alias is only supported for domains hosted on Amazon Route 53. Do not set the "customDomain.domainAlias" when "isExternalDomain" is enabled.`);
            }
            if (customDomain.hostedZone) {
                throw new Error(`Hosted zones can only be configured for domains hosted on Amazon Route 53. Do not set the "customDomain.hostedZone" when "isExternalDomain" is enabled.`);
            }
        }
    }
    lookupHostedZone() {
        const { customDomain } = this.props;
        // Skip if customDomain is not configured
        if (!customDomain) {
            return;
        }
        let hostedZone;
        if (typeof customDomain === "string") {
            hostedZone = HostedZone.fromLookup(this, "HostedZone", {
                domainName: customDomain,
            });
        }
        else if (customDomain.cdk?.hostedZone) {
            hostedZone = customDomain.cdk.hostedZone;
        }
        else if (typeof customDomain.hostedZone === "string") {
            hostedZone = HostedZone.fromLookup(this, "HostedZone", {
                domainName: customDomain.hostedZone,
            });
        }
        else if (typeof customDomain.domainName === "string") {
            // Skip if domain is not a Route53 domain
            if (customDomain.isExternalDomain === true) {
                return;
            }
            hostedZone = HostedZone.fromLookup(this, "HostedZone", {
                domainName: customDomain.domainName,
            });
        }
        else {
            hostedZone = customDomain.hostedZone;
        }
        return hostedZone;
    }
    createCertificate() {
        const { customDomain } = this.props;
        if (!customDomain) {
            return;
        }
        let acmCertificate;
        // HostedZone is set for Route 53 domains
        if (this.hostedZone) {
            if (typeof customDomain === "string") {
                acmCertificate = new DnsValidatedCertificate(this, "Certificate", {
                    domainName: customDomain,
                    hostedZone: this.hostedZone,
                    region: "us-east-1",
                });
            }
            else if (customDomain.cdk?.certificate) {
                acmCertificate = customDomain.cdk.certificate;
            }
            else {
                acmCertificate = new DnsValidatedCertificate(this, "Certificate", {
                    domainName: customDomain.domainName,
                    hostedZone: this.hostedZone,
                    region: "us-east-1",
                });
            }
        }
        // HostedZone is NOT set for non-Route 53 domains
        else {
            if (typeof customDomain !== "string") {
                acmCertificate = customDomain.cdk?.certificate;
            }
        }
        return acmCertificate;
    }
    createRoute53Records() {
        const { customDomain } = this.props;
        if (!customDomain || !this.hostedZone) {
            return;
        }
        let recordName;
        let domainAlias;
        if (typeof customDomain === "string") {
            recordName = customDomain;
        }
        else {
            recordName = customDomain.domainName;
            domainAlias = customDomain.domainAlias;
        }
        // Create DNS record
        const recordProps = {
            recordName,
            zone: this.hostedZone,
            target: RecordTarget.fromAlias(new CloudFrontTarget(this.distribution)),
        };
        new ARecord(this, "AliasRecord", recordProps);
        new AaaaRecord(this, "AliasRecordAAAA", recordProps);
        // Create Alias redirect record
        if (domainAlias) {
            new HttpsRedirect(this, "Redirect", {
                zone: this.hostedZone,
                recordNames: [domainAlias],
                targetDomain: recordName,
            });
        }
    }
    /////////////////////
    // Helper Functions
    /////////////////////
    getS3ContentReplaceValues() {
        const replaceValues = this.props.replaceValues || [];
        Object.entries(this.props.environment || {})
            .filter(([, value]) => Token.isUnresolved(value))
            .forEach(([key, value]) => {
            const token = `{{ ${key} }}`;
            replaceValues.push({
                files: "**/*.html",
                search: token,
                replace: value,
            }, {
                files: "**/*.js",
                search: token,
                replace: value,
            });
        });
        return replaceValues;
    }
}
