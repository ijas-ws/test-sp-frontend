import path from "path";
import url from "url";
import fs from "fs";
import glob from "glob";
import crypto from "crypto";
import spawn from "cross-spawn";
import { execSync } from "child_process";
import { Construct } from "constructs";
import { Fn, Token, Duration as CdkDuration, RemovalPolicy, CustomResource, } from "aws-cdk-lib";
import { BlockPublicAccess, Bucket, } from "aws-cdk-lib/aws-s3";
import { Role, Effect, Policy, PolicyStatement, AnyPrincipal, } from "aws-cdk-lib/aws-iam";
import { Function as CdkFunction, Code, Runtime, FunctionUrlAuthType, } from "aws-cdk-lib/aws-lambda";
import { HostedZone, ARecord, AaaaRecord, RecordTarget, } from "aws-cdk-lib/aws-route53";
import { Asset } from "aws-cdk-lib/aws-s3-assets";
import { Distribution, ViewerProtocolPolicy, AllowedMethods, CachedMethods, LambdaEdgeEventType, CachePolicy, CacheQueryStringBehavior, CacheHeaderBehavior, CacheCookieBehavior, OriginRequestPolicy, Function as CfFunction, FunctionCode as CfFunctionCode, FunctionEventType as CfFunctionEventType, } from "aws-cdk-lib/aws-cloudfront";
import { AwsCliLayer } from "aws-cdk-lib/lambda-layer-awscli";
import { S3Origin, HttpOrigin } from "aws-cdk-lib/aws-cloudfront-origins";
import { CloudFrontTarget } from "aws-cdk-lib/aws-route53-targets";
import { Stack } from "./Stack.js";
import { Logger } from "../logger.js";
import { createAppContext } from "./context.js";
import { isCDKConstruct } from "./Construct.js";
import { Secret } from "./Secret.js";
import { SsrFunction } from "./SsrFunction.js";
import { getBuildCmdEnvironment, } from "./BaseSite.js";
import { HttpsRedirect } from "./cdk/website-redirect.js";
import { DnsValidatedCertificate } from "./cdk/dns-validated-certificate.js";
import { attachPermissionsToRole } from "./util/permission.js";
import { getParameterPath, } from "./util/functionBinding.js";
import { useProject } from "../project.js";
const __dirname = url.fileURLToPath(new URL(".", import.meta.url));
/**
 * The `SsrSite` construct is a higher level CDK construct that makes it easy to create modern web apps with Server Side Rendering capabilities.
 * @example
 * Deploys an Astro app in the `web` directory.
 *
 * ```js
 * new SsrSite(stack, "site", {
 *   path: "web",
 * });
 * ```
 */
export class SsrSite extends Construct {
    id;
    props;
    doNotDeploy;
    buildConfig;
    serverLambdaForEdge;
    serverLambdaForRegional;
    serverLambdaForDev;
    bucket;
    cfFunction;
    distribution;
    hostedZone;
    certificate;
    constructor(scope, id, props) {
        super(scope, props?.cdk?.id || id);
        const app = scope.node.root;
        const stack = Stack.of(this);
        this.id = id;
        this.props = {
            path: ".",
            waitForInvalidation: false,
            runtime: "nodejs18.x",
            timeout: "10 seconds",
            memorySize: "1024 MB",
            ...props,
        };
        this.doNotDeploy =
            !stack.isActive || (app.mode === "dev" && !this.props.dev?.deploy);
        this.buildConfig = this.initBuildConfig();
        this.validateSiteExists();
        this.writeTypesFile();
        useSites().add(id, this.constructor.name, this.props);
        if (this.doNotDeploy) {
            // @ts-ignore
            this.cfFunction = this.bucket = this.distribution = null;
            this.serverLambdaForDev = this.createFunctionForDev();
            return;
        }
        const cliLayer = new AwsCliLayer(this, "AwsCliLayer");
        // Build app
        this.buildApp();
        // Create Bucket which will be utilised to contain the statics
        this.bucket = this.createS3Bucket();
        // Create Server functions
        if (this.props.edge) {
            this.serverLambdaForEdge = this.createFunctionForEdge();
            this.createFunctionPermissionsForEdge();
        }
        else {
            this.serverLambdaForRegional = this.createFunctionForRegional();
            this.createFunctionPermissionsForRegional();
        }
        // Create Custom Domain
        this.validateCustomDomainSettings();
        this.hostedZone = this.lookupHostedZone();
        this.certificate = this.createCertificate();
        // Create S3 Deployment
        const assets = this.createS3Assets();
        const assetFileOptions = this.createS3AssetFileOptions();
        const s3deployCR = this.createS3Deployment(cliLayer, assets, assetFileOptions);
        // Create CloudFront
        this.validateCloudFrontDistributionSettings();
        this.cfFunction = this.createCloudFrontFunction();
        this.distribution = this.props.edge
            ? this.createCloudFrontDistributionForEdge()
            : this.createCloudFrontDistributionForRegional();
        this.distribution.node.addDependency(s3deployCR);
        // Invalidate CloudFront
        this.createCloudFrontInvalidation();
        // Connect Custom Domain to CloudFront Distribution
        this.createRoute53Records();
    }
    /////////////////////
    // Public Properties
    /////////////////////
    /**
     * The CloudFront URL of the website.
     */
    get url() {
        if (this.doNotDeploy)
            return;
        return `https://${this.distribution.distributionDomainName}`;
    }
    /**
     * If the custom domain is enabled, this is the URL of the website with the
     * custom domain.
     */
    get customDomainUrl() {
        if (this.doNotDeploy)
            return;
        const { customDomain } = this.props;
        if (!customDomain)
            return;
        if (typeof customDomain === "string") {
            return `https://${customDomain}`;
        }
        else {
            return `https://${customDomain.domainName}`;
        }
    }
    /**
     * The internally created CDK resources.
     */
    get cdk() {
        if (this.doNotDeploy)
            return;
        return {
            function: this.serverLambdaForRegional,
            bucket: this.bucket,
            distribution: this.distribution,
            hostedZone: this.hostedZone,
            certificate: this.certificate,
        };
    }
    /////////////////////
    // Public Methods
    /////////////////////
    /**
     * Attaches the given list of permissions to allow the Astro server side
     * rendering to access other AWS resources.
     *
     * @example
     * ```js
     * site.attachPermissions(["sns"]);
     * ```
     */
    attachPermissions(permissions) {
        this.serverLambdaForEdge?.attachPermissions(permissions);
        if (this.serverLambdaForDev) {
            attachPermissionsToRole(this.serverLambdaForDev.role, permissions);
        }
        if (this.serverLambdaForRegional) {
            attachPermissionsToRole(this.serverLambdaForRegional.role, permissions);
        }
    }
    /** @internal */
    getConstructMetadata() {
        return {
            type: this.constructor.name,
            data: {
                mode: this.doNotDeploy
                    ? "placeholder"
                    : "deployed",
                path: this.props.path,
                customDomainUrl: this.customDomainUrl,
                edge: this.props.edge,
                server: (this.serverLambdaForDev ||
                    this.serverLambdaForRegional ||
                    this.serverLambdaForEdge)?.functionArn,
                secrets: (this.props.bind || [])
                    .filter((c) => c instanceof Secret)
                    .map((c) => c.name),
            },
        };
    }
    /** @internal */
    getFunctionBinding() {
        const app = this.node.root;
        return {
            clientPackage: "site",
            variables: {
                url: this.doNotDeploy
                    ? {
                        type: "plain",
                        value: "localhost",
                    }
                    : {
                        // Do not set real value b/c we don't want to make the Lambda function
                        // depend on the Site. B/c often the site depends on the Api, causing
                        // a CloudFormation circular dependency if the Api and the Site belong
                        // to different stacks.
                        type: "site_url",
                        value: this.customDomainUrl || this.url,
                    },
            },
            permissions: {
                "ssm:GetParameters": [
                    `arn:${Stack.of(this).partition}:ssm:${app.region}:${app.account}:parameter${getParameterPath(this, "url")}`,
                ],
            },
        };
    }
    /////////////////////
    // Build App
    /////////////////////
    initBuildConfig() {
        return {
            typesPath: ".",
            serverBuildOutputFile: "placeholder",
            clientBuildOutputDir: "placeholder",
            clientBuildVersionedSubDir: "placeholder",
        };
    }
    buildApp() {
        const app = this.node.root;
        if (!app.isRunningSSTTest()) {
            this.runBuild();
        }
        this.validateBuildOutput();
    }
    validateBuildOutput() {
        const serverBuildFile = path.join(this.props.path, this.buildConfig.serverBuildOutputFile);
        if (!fs.existsSync(serverBuildFile)) {
            throw new Error(`No server build output found at "${serverBuildFile}"`);
        }
    }
    runBuild() {
        const { path: sitePath, buildCommand: rawBuildCommand, environment, } = this.props;
        const defaultCommand = "npm run build";
        const buildCommand = rawBuildCommand || defaultCommand;
        if (buildCommand === defaultCommand) {
            // Ensure that the site has a build script defined
            if (!fs.existsSync(path.join(sitePath, "package.json"))) {
                throw new Error(`No package.json found at "${sitePath}".`);
            }
            const packageJson = JSON.parse(fs.readFileSync(path.join(sitePath, "package.json")).toString());
            if (!packageJson.scripts || !packageJson.scripts.build) {
                throw new Error(`No "build" script found within package.json in "${sitePath}".`);
            }
        }
        // Run build
        Logger.debug(`Running "${buildCommand}" script`);
        try {
            execSync(buildCommand, {
                cwd: sitePath,
                stdio: "inherit",
                env: {
                    ...process.env,
                    ...getBuildCmdEnvironment(environment),
                },
            });
        }
        catch (e) {
            throw new Error(`There was a problem building the "${this.node.id}" StaticSite.`);
        }
    }
    /////////////////////
    // Bundle S3 Assets
    /////////////////////
    createS3Assets() {
        // Create temp folder, clean up if exists
        const zipOutDir = path.resolve(path.join(useProject().paths.artifacts, `Site-${this.node.id}-${this.node.addr}`));
        fs.rmSync(zipOutDir, { recursive: true, force: true });
        // Create zip files
        const app = this.node.root;
        const script = path.resolve(__dirname, "../support/base-site-archiver.mjs");
        const fileSizeLimit = app.isRunningSSTTest()
            ? // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore: "sstTestFileSizeLimitOverride" not exposed in props
                this.props.sstTestFileSizeLimitOverride || 200
            : 200;
        const result = spawn.sync("node", [
            script,
            [
                path.join(this.props.path, this.buildConfig.clientBuildOutputDir),
                ...(this.buildConfig.prerenderedBuildOutputDir
                    ? [
                        path.join(this.props.path, this.buildConfig.prerenderedBuildOutputDir),
                    ]
                    : []),
            ].join(","),
            zipOutDir,
            `${fileSizeLimit}`,
        ], {
            stdio: "inherit",
        });
        if (result.status !== 0) {
            throw new Error(`There was a problem generating the assets package.`);
        }
        // Create S3 Assets for each zip file
        const assets = [];
        for (let partId = 0;; partId++) {
            const zipFilePath = path.join(zipOutDir, `part${partId}.zip`);
            if (!fs.existsSync(zipFilePath)) {
                break;
            }
            assets.push(new Asset(this, `Asset${partId}`, {
                path: zipFilePath,
            }));
        }
        return assets;
    }
    createS3AssetFileOptions() {
        // Build file options
        const fileOptions = [];
        const clientPath = path.join(this.props.path, this.buildConfig.clientBuildOutputDir);
        for (const item of fs.readdirSync(clientPath)) {
            // Versioned files will be cached for 1 year (immutable) both at
            // CDN and browser level.
            if (item === this.buildConfig.clientBuildVersionedSubDir) {
                fileOptions.push({
                    exclude: "*",
                    include: `${this.buildConfig.clientBuildVersionedSubDir}/*`,
                    cacheControl: "public,max-age=31536000,immutable",
                });
            }
            // Un-versioned files will be cached for 1 year at the CDN level.
            // But not at the browser level. CDN cache will be invalidated on deploy.
            else {
                const itemPath = path.join(clientPath, item);
                fileOptions.push({
                    exclude: "*",
                    include: fs.statSync(itemPath).isDirectory()
                        ? `${item}/*`
                        : `${item}`,
                    cacheControl: "public,max-age=0,s-maxage=31536000,must-revalidate",
                });
            }
        }
        return fileOptions;
    }
    createS3Bucket() {
        const { cdk } = this.props;
        // cdk.bucket is an imported construct
        if (cdk?.bucket && isCDKConstruct(cdk?.bucket)) {
            return cdk.bucket;
        }
        // cdk.bucket is a prop
        else {
            const bucketProps = cdk?.bucket;
            return new Bucket(this, "S3Bucket", {
                publicReadAccess: false,
                blockPublicAccess: BlockPublicAccess.BLOCK_ALL,
                autoDeleteObjects: true,
                removalPolicy: RemovalPolicy.DESTROY,
                ...bucketProps,
            });
        }
    }
    createS3Deployment(cliLayer, assets, fileOptions) {
        // Create a Lambda function that will be doing the uploading
        const uploader = new CdkFunction(this, "S3Uploader", {
            code: Code.fromAsset(path.join(__dirname, "../support/base-site-custom-resource")),
            layers: [cliLayer],
            runtime: Runtime.PYTHON_3_7,
            handler: "s3-upload.handler",
            timeout: CdkDuration.minutes(15),
            memorySize: 1024,
        });
        this.bucket.grantReadWrite(uploader);
        assets.forEach((asset) => asset.grantRead(uploader));
        // Create the custom resource function
        const handler = new CdkFunction(this, "S3Handler", {
            code: Code.fromAsset(path.join(__dirname, "../support/base-site-custom-resource")),
            layers: [cliLayer],
            runtime: Runtime.PYTHON_3_7,
            handler: "s3-handler.handler",
            timeout: CdkDuration.minutes(15),
            memorySize: 1024,
            environment: {
                UPLOADER_FUNCTION_NAME: uploader.functionName,
            },
        });
        this.bucket.grantReadWrite(handler);
        uploader.grantInvoke(handler);
        // Create custom resource
        return new CustomResource(this, "S3Deployment", {
            serviceToken: handler.functionArn,
            resourceType: "Custom::SSTBucketDeployment",
            properties: {
                Sources: assets.map((asset) => ({
                    BucketName: asset.s3BucketName,
                    ObjectKey: asset.s3ObjectKey,
                })),
                DestinationBucketName: this.bucket.bucketName,
                FileOptions: (fileOptions || []).map(({ exclude, include, cacheControl }) => {
                    return [
                        "--exclude",
                        exclude,
                        "--include",
                        include,
                        "--cache-control",
                        cacheControl,
                    ];
                }),
                ReplaceValues: this.getS3ContentReplaceValues(),
            },
        });
    }
    /////////////////////
    // Bundle Lambda Server
    /////////////////////
    createFunctionForRegional() {
        return {};
    }
    createFunctionForEdge() {
        return {};
    }
    createFunctionForDev() {
        const { runtime, timeout, memorySize, permissions, environment, bind } = this.props;
        const role = new Role(this, "ServerFunctionRole", {
            assumedBy: new AnyPrincipal(),
            maxSessionDuration: CdkDuration.hours(12),
        });
        const ssrFn = new SsrFunction(this, `ServerFunction`, {
            description: "Server handler placeholder",
            bundle: path.join(__dirname, "../support/ssr-site-function-stub"),
            handler: "index.handler",
            runtime,
            memorySize,
            timeout,
            role,
            bind,
            environment,
            permissions,
            // note: do not need to set vpc settings b/c this function is not being used
        });
        return ssrFn.function;
    }
    createFunctionPermissionsForRegional() {
        this.bucket.grantReadWrite(this.serverLambdaForRegional.role);
    }
    createFunctionPermissionsForEdge() {
        this.bucket.grantReadWrite(this.serverLambdaForEdge.role);
    }
    /////////////////////
    // CloudFront Distribution
    /////////////////////
    validateCloudFrontDistributionSettings() {
        const { cdk } = this.props;
        if (cdk?.distribution?.certificate) {
            throw new Error(`Do not configure the "cfDistribution.certificate". Use the "customDomain" to configure the domain certificate.`);
        }
        if (cdk?.distribution?.domainNames) {
            throw new Error(`Do not configure the "cfDistribution.domainNames". Use the "customDomain" to configure the domain name.`);
        }
    }
    createCloudFrontFunction() {
        return new CfFunction(this, "CloudFrontFunction", {
            code: CfFunctionCode.fromInline(`
function handler(event) {
  var request = event.request;
  request.headers["x-forwarded-host"] = request.headers.host;
  ${this.buildConfig.serverCFFunctionInjection || ""}
  return request;
}`),
        });
    }
    createCloudFrontDistributionForRegional() {
        const { cdk } = this.props;
        const cfDistributionProps = cdk?.distribution || {};
        const s3Origin = new S3Origin(this.bucket);
        return new Distribution(this, "Distribution", {
            // these values can be overwritten by cfDistributionProps
            defaultRootObject: "",
            // Override props.
            ...cfDistributionProps,
            // these values can NOT be overwritten by cfDistributionProps
            domainNames: this.buildDistributionDomainNames(),
            certificate: this.certificate,
            defaultBehavior: this.buildDefaultBehaviorForRegional(),
            additionalBehaviors: {
                ...this.buildStaticFileBehaviors(s3Origin),
                ...(cfDistributionProps.additionalBehaviors || {}),
            },
        });
    }
    createCloudFrontDistributionForEdge() {
        const { cdk } = this.props;
        const cfDistributionProps = cdk?.distribution || {};
        const s3Origin = new S3Origin(this.bucket);
        return new Distribution(this, "Distribution", {
            // these values can be overwritten by cfDistributionProps
            defaultRootObject: "",
            // Override props.
            ...cfDistributionProps,
            // these values can NOT be overwritten by cfDistributionProps
            domainNames: this.buildDistributionDomainNames(),
            certificate: this.certificate,
            defaultBehavior: this.buildDefaultBehaviorForEdge(s3Origin),
            additionalBehaviors: {
                ...this.buildStaticFileBehaviors(s3Origin),
                ...(cfDistributionProps.additionalBehaviors || {}),
            },
        });
    }
    buildDistributionDomainNames() {
        const { customDomain } = this.props;
        const domainNames = [];
        if (!customDomain) {
            // no domain
        }
        else if (typeof customDomain === "string") {
            domainNames.push(customDomain);
        }
        else {
            domainNames.push(customDomain.domainName);
            if (customDomain.alternateNames) {
                if (!customDomain.cdk?.certificate)
                    throw new Error("Certificates for alternate domains cannot be automatically created. Please specify certificate to use");
                domainNames.push(...customDomain.alternateNames);
            }
        }
        return domainNames;
    }
    buildDefaultBehaviorForRegional() {
        const { cdk } = this.props;
        const cfDistributionProps = cdk?.distribution || {};
        const fnUrl = this.serverLambdaForRegional.addFunctionUrl({
            authType: FunctionUrlAuthType.NONE,
        });
        return {
            viewerProtocolPolicy: ViewerProtocolPolicy.REDIRECT_TO_HTTPS,
            functionAssociations: this.buildBehaviorFunctionAssociations(),
            origin: new HttpOrigin(Fn.parseDomainName(fnUrl.url)),
            allowedMethods: AllowedMethods.ALLOW_ALL,
            cachedMethods: CachedMethods.CACHE_GET_HEAD_OPTIONS,
            compress: true,
            cachePolicy: cdk?.serverCachePolicy ?? this.buildServerCachePolicy(),
            originRequestPolicy: this.buildServerOriginRequestPolicy(),
            ...(cfDistributionProps.defaultBehavior || {}),
        };
    }
    buildDefaultBehaviorForEdge(origin) {
        const { cdk } = this.props;
        const cfDistributionProps = cdk?.distribution || {};
        return {
            viewerProtocolPolicy: ViewerProtocolPolicy.REDIRECT_TO_HTTPS,
            functionAssociations: this.buildBehaviorFunctionAssociations(),
            origin,
            allowedMethods: AllowedMethods.ALLOW_ALL,
            cachedMethods: CachedMethods.CACHE_GET_HEAD_OPTIONS,
            compress: true,
            cachePolicy: cdk?.serverCachePolicy ?? this.buildServerCachePolicy(),
            originRequestPolicy: this.buildServerOriginRequestPolicy(),
            ...(cfDistributionProps.defaultBehavior || {}),
            edgeLambdas: [
                {
                    includeBody: true,
                    eventType: LambdaEdgeEventType.ORIGIN_REQUEST,
                    functionVersion: this.serverLambdaForEdge.currentVersion,
                },
                ...(cfDistributionProps.defaultBehavior?.edgeLambdas || []),
            ],
        };
    }
    buildBehaviorFunctionAssociations() {
        return [
            {
                eventType: CfFunctionEventType.VIEWER_REQUEST,
                function: this.cfFunction,
            },
        ];
    }
    buildStaticFileBehaviors(origin) {
        const { cdk } = this.props;
        // Create additional behaviours for statics
        const staticBehaviourOptions = {
            viewerProtocolPolicy: ViewerProtocolPolicy.REDIRECT_TO_HTTPS,
            origin,
            allowedMethods: AllowedMethods.ALLOW_GET_HEAD_OPTIONS,
            cachedMethods: CachedMethods.CACHE_GET_HEAD_OPTIONS,
            compress: true,
            cachePolicy: CachePolicy.CACHING_OPTIMIZED,
        };
        // Add behaviour for public folder statics (excluding build)
        const staticsBehaviours = {};
        const publicDir = path.join(this.props.path, this.buildConfig.clientBuildOutputDir);
        for (const item of fs.readdirSync(publicDir)) {
            if (fs.statSync(path.join(publicDir, item)).isDirectory()) {
                staticsBehaviours[`${item}/*`] = staticBehaviourOptions;
            }
            else {
                staticsBehaviours[item] = staticBehaviourOptions;
            }
        }
        return staticsBehaviours;
    }
    buildServerCachePolicy(allowedHeaders) {
        return new CachePolicy(this, "ServerCache", {
            queryStringBehavior: CacheQueryStringBehavior.all(),
            headerBehavior: allowedHeaders && allowedHeaders.length > 0
                ? CacheHeaderBehavior.allowList(...allowedHeaders)
                : CacheHeaderBehavior.none(),
            cookieBehavior: CacheCookieBehavior.all(),
            defaultTtl: CdkDuration.days(0),
            maxTtl: CdkDuration.days(365),
            minTtl: CdkDuration.days(0),
            enableAcceptEncodingBrotli: true,
            enableAcceptEncodingGzip: true,
            comment: "SST server response cache policy",
        });
    }
    buildServerOriginRequestPolicy() {
        // CloudFront's Managed-AllViewerExceptHostHeader policy
        return OriginRequestPolicy.fromOriginRequestPolicyId(this, "ServerOriginRequestPolicy", "b689b0a8-53d0-40ab-baf2-68738e2966ac");
    }
    createCloudFrontInvalidation() {
        const stack = Stack.of(this);
        const policy = new Policy(this, "CloudFrontInvalidatorPolicy", {
            statements: [
                new PolicyStatement({
                    effect: Effect.ALLOW,
                    actions: [
                        "cloudfront:GetInvalidation",
                        "cloudfront:CreateInvalidation",
                    ],
                    resources: [
                        `arn:${stack.partition}:cloudfront::${stack.account}:distribution/${this.distribution.distributionId}`,
                    ],
                }),
            ],
        });
        stack.customResourceHandler.role?.attachInlinePolicy(policy);
        const resource = new CustomResource(this, "CloudFrontInvalidator", {
            serviceToken: stack.customResourceHandler.functionArn,
            resourceType: "Custom::CloudFrontInvalidator",
            properties: {
                buildId: this.generateBuildId(),
                distributionId: this.distribution.distributionId,
                paths: ["/*"],
                waitForInvalidation: this.props.waitForInvalidation,
            },
        });
        resource.node.addDependency(policy);
        return resource;
    }
    /////////////////////
    // Custom Domain
    /////////////////////
    validateCustomDomainSettings() {
        const { customDomain } = this.props;
        if (!customDomain) {
            return;
        }
        if (typeof customDomain === "string") {
            return;
        }
        if (customDomain.isExternalDomain === true) {
            if (!customDomain.cdk?.certificate) {
                throw new Error(`A valid certificate is required when "isExternalDomain" is set to "true".`);
            }
            if (customDomain.domainAlias) {
                throw new Error(`Domain alias is only supported for domains hosted on Amazon Route 53. Do not set the "customDomain.domainAlias" when "isExternalDomain" is enabled.`);
            }
            if (customDomain.hostedZone) {
                throw new Error(`Hosted zones can only be configured for domains hosted on Amazon Route 53. Do not set the "customDomain.hostedZone" when "isExternalDomain" is enabled.`);
            }
        }
    }
    lookupHostedZone() {
        const { customDomain } = this.props;
        // Skip if customDomain is not configured
        if (!customDomain) {
            return;
        }
        let hostedZone;
        if (typeof customDomain === "string") {
            hostedZone = HostedZone.fromLookup(this, "HostedZone", {
                domainName: customDomain,
            });
        }
        else if (customDomain.cdk?.hostedZone) {
            hostedZone = customDomain.cdk.hostedZone;
        }
        else if (typeof customDomain.hostedZone === "string") {
            hostedZone = HostedZone.fromLookup(this, "HostedZone", {
                domainName: customDomain.hostedZone,
            });
        }
        else if (typeof customDomain.domainName === "string") {
            // Skip if domain is not a Route53 domain
            if (customDomain.isExternalDomain === true) {
                return;
            }
            hostedZone = HostedZone.fromLookup(this, "HostedZone", {
                domainName: customDomain.domainName,
            });
        }
        else {
            hostedZone = customDomain.hostedZone;
        }
        return hostedZone;
    }
    createCertificate() {
        const { customDomain } = this.props;
        if (!customDomain) {
            return;
        }
        let acmCertificate;
        // HostedZone is set for Route 53 domains
        if (this.hostedZone) {
            if (typeof customDomain === "string") {
                acmCertificate = new DnsValidatedCertificate(this, "Certificate", {
                    domainName: customDomain,
                    hostedZone: this.hostedZone,
                    region: "us-east-1",
                });
            }
            else if (customDomain.cdk?.certificate) {
                acmCertificate = customDomain.cdk.certificate;
            }
            else {
                acmCertificate = new DnsValidatedCertificate(this, "Certificate", {
                    domainName: customDomain.domainName,
                    hostedZone: this.hostedZone,
                    region: "us-east-1",
                });
            }
        }
        // HostedZone is NOT set for non-Route 53 domains
        else {
            if (typeof customDomain !== "string") {
                acmCertificate = customDomain.cdk?.certificate;
            }
        }
        return acmCertificate;
    }
    createRoute53Records() {
        const { customDomain } = this.props;
        if (!customDomain || !this.hostedZone) {
            return;
        }
        let recordName;
        let domainAlias;
        if (typeof customDomain === "string") {
            recordName = customDomain;
        }
        else {
            recordName = customDomain.domainName;
            domainAlias = customDomain.domainAlias;
        }
        // Create DNS record
        const recordProps = {
            recordName,
            zone: this.hostedZone,
            target: RecordTarget.fromAlias(new CloudFrontTarget(this.distribution)),
        };
        new ARecord(this, "AliasRecord", recordProps);
        new AaaaRecord(this, "AliasRecordAAAA", recordProps);
        // Create Alias redirect record
        if (domainAlias) {
            new HttpsRedirect(this, "Redirect", {
                zone: this.hostedZone,
                recordNames: [domainAlias],
                targetDomain: recordName,
            });
        }
    }
    /////////////////////
    // Helper Functions
    /////////////////////
    getS3ContentReplaceValues() {
        const replaceValues = [];
        Object.entries(this.props.environment || {})
            .filter(([, value]) => Token.isUnresolved(value))
            .forEach(([key, value]) => {
            const token = `{{ ${key} }}`;
            replaceValues.push({
                files: "**/*.html",
                search: token,
                replace: value,
            }, {
                files: "**/*.js",
                search: token,
                replace: value,
            }, {
                files: "**/*.json",
                search: token,
                replace: value,
            });
        });
        return replaceValues;
    }
    validateSiteExists() {
        const { path: sitePath } = this.props;
        if (!fs.existsSync(sitePath)) {
            throw new Error(`No site found at "${path.resolve(sitePath)}"`);
        }
    }
    writeTypesFile() {
        const typesPath = path.resolve(this.props.path, this.buildConfig.typesPath, "sst-env.d.ts");
        // Do not override the types file if it already exists
        if (fs.existsSync(typesPath))
            return;
        const relPathToSstTypesFile = path.join(path.relative(path.dirname(typesPath), useProject().paths.root), ".sst/types/index.ts");
        fs.writeFileSync(typesPath, `/// <reference path="${relPathToSstTypesFile}" />`);
    }
    generateBuildId() {
        // We will generate a hash based on the contents of the "public" folder
        // which will be used to indicate if we need to invalidate our CloudFront
        // cache. As the browser build files are always uniquely hash in their
        // filenames according to their content we can ignore the browser build
        // files.
        // The below options are needed to support following symlinks when building zip files:
        // - nodir: This will prevent symlinks themselves from being copied into the zip.
        // - follow: This will follow symlinks and copy the files within.
        const globOptions = {
            dot: true,
            nodir: true,
            follow: true,
            ignore: [`${this.buildConfig.clientBuildVersionedSubDir}/**`],
            cwd: path.resolve(this.props.path, this.buildConfig.clientBuildOutputDir),
        };
        const files = glob.sync("**", globOptions);
        const hash = crypto.createHash("sha1");
        for (const file of files) {
            hash.update(file);
        }
        const buildId = hash.digest("hex");
        Logger.debug(`Generated build ID ${buildId}`);
        return buildId;
    }
}
export const useSites = createAppContext(() => {
    const sites = [];
    return {
        add(name, type, props) {
            sites.push({ name, type, props });
        },
        get all() {
            return sites;
        },
    };
});
